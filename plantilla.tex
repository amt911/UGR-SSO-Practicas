%TODO: PONER IMAGENES DE EJEMPLO DE LOS FICHEROS DEL EJERCICIO 1
%TODO 2: INTENTAR QUITAR LA MORRAYA QUE NO SIRVA
%TODO 3: INTENTAR NO REPETIR TANTAS COSAS EN EL EJERCICIO 3
\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx, graphics, float, hyperref}
\usepackage{listings}
\usepackage[a4paper, total={6in, 10in}]{geometry}

\title{SSO Práctica 1}
\author{Andrés Merlo Trujillo}
\date{}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
}

\begin{document}

\maketitle

\tableofcontents

\section{Primer ejercicio}
A continuación, voy a explicar el formato y el significado de cada uno de los campos. Para ello, voy a dividir cada archivo en subsecciones:

\subsection{/etc/passwd}
Este fichero está formado por líneas de 7 campos separados por ``:''. Los campos y sus significados son los siguientes:

\begin{enumerate}
    \item \textbf{Nombre de login: }Nombre de usuario.
    \item \textbf{Contraseña encriptada opcional: }Contraseña encriptada del usuario.
    Si este campo tiene la letra ``x'' minuscula, significa que la contraseña se almacena en ``/etc/shadow''.

    Si se encuentra vacio, significa que no hace falta contraseña para autenticar.

    Si comienza en exclamacion, significa que la contraseña ha sido bloqueada.

    Ademas, si contiene una exclamacion o un asterisco, significa que el usuario no podra usar la contraseña para iniciar sesion (pero puede usar otro medio).

    \item \textbf{User ID numerico: }ID del usuario.
    \item \textbf{Group ID numerico: }ID del grupo al que pertenece.
    \item \textbf{Nombre de usuario o campo de comentario: }Este campo sirve para poder poner un comentario sobre el usuario (por ejemplo: accion que realiza, para evitar confusion con dos usuarios similares, etc).
    \item \textbf{Directorio home del usuario: }Directorio que será el home privado del usuario. Además sirve para poner la variable de entorno ``\$HOME''
    \item \textbf{Interprete opcional de comando de usuario: }Shell que usará el usuario por defecto (bash, sh, zsh, fish, etc). Ademas, pondra la variable de entorno ``\$SHELL'' a este valor.
\end{enumerate}


\subsection{/etc/group}
Este fichero está formado por 4 campos separados por ``:''. EL significado de cada campo es el siguiente:

\begin{enumerate}
    \item \textbf{Nombre del grupo: }Nombre del grupo. Este nombre debe ser único en el sistema.
    
    %REVISAR ESTE CAMPO
    \item \textbf{Contraseña: }Contraseña del grupo. Si es una letra ``x'' minuscula significa que la contraseña encriptada se encuentra en ``/etc/gpasswd''.
    \item \textbf{Group ID: }Indica el ID del grupo. Este valor debe ser único en el sistema.
    \item \textbf{Usuarios: }Lista de ususarios separados por coma (``,'') los cuales son miembros del grupo. 
\end{enumerate}
\subsection{/etc/shadow}
Este fichero está formado por líneas de 9 campos separados por ``:''. Los campos y sus significados son los siguientes:

\begin{enumerate}
    \item \textbf{login name (nombre de login): }Nombre de la cuenta del usuario. Debe existir en el sistema.
    
    %Hablar de la encriptacion concreta que tiene (quizas sea un salteo)
    \item \textbf{encrypted password (contraseña encryptada): }Contraseña encriptada del usuario especificado en ``login name''. Si este campo está vacío, significa que ese usuario no requiere contraseña para iniciar sesion. 
    
    Además, en caso de que la contraseña comience con una exclamacion (``!''), significa que la contraseña ha sido bloqueada.

    Por último, si la contraseña contiene el carácter de exclamacion mencionado anteriormente o asterisco (``*''), significa que no puede iniciar sesión (si es exclamación también se cumple lo de arriba).

    \item \textbf{date of last password change (fecha del ultimo cambio de contraseña): }El último cambio de contraseña, expresado como el numero de dias desde el epoch (1 de enero de 1970).
    
    Además, si el valor es 0 significa que el usuario debe cambiar la contraseña en el proximo login.

    %comprobar este parrafo
    En cambio, si el campo está vacio signicia que las contraseñas no tienen edad (y por tanto no se cumplen estas restricciones).

    \item \textbf{minimum password age (edad minima de la contraseña): }Numero de dias que el usuario tiene que esperar antes de poder cambiar la contraseña de nuevo. Un valor 0 ó vacio indica que no hay un minimo de dias.
    \item \textbf{maximum password age (edad maxima de la contraseña): }Numero maximo de dias en los cuales la contraseña ``caduca'' (tiene que cambiarla). Al pasar este numero de dias, el sistema pedira al usuario que cambie la contraseña.
    
    Si el valor maximo es mayor que el del campo anterior, el usuario no podra cambiar su contraseña.

    Por último, si el campo está vacio, se deshabilitara este servicio junto con ``password warning period'' y ``password inactivity period''.

    \item \textbf{password warning period (periodo de advertencia de la contraseña): }El numero de dias antes de que la contraseña ``caduqeu'' durante los cuales se le  advierte al usuario.
    
    Un valor 0 o cadena vacia indica que no habra advertencias.

    \item \textbf{password inactivity period (periodo de inactividad de la contraseña): }Numero de dias despues de que la contraseña haya ``caducado'' en el cual eberia ser aceptada. Al pasar este eriodo, el usuario no podra iniciar sesion.
    
    Un campo vacio indica que no se cumple esta regla.

    \item  \textbf{account expiration date (fecha de expiracion de la cuenta): }La fecha en la que la cuenta expira. Esta fecha se exresa como el numero de dias desde el epoch.
    
    La diferencia con la expiracion de una contraseña es que, si la cuenta expira, no podra iniciar sesion de ninguna forma, mientras que si la contraseña expira, tendrá otros medios para iniciar sesion.

    El campo vacio indica que la cuenta no expira. Ademas, no se debe usar el valor 0 ya que se puede interpretar como que la cuenta expira en el epoch o que no expira.

    \item \textbf{reserved field (campo reservado): }Este campo está reservado para usos futuros.
\end{enumerate}

\subsection{/etc/gshadow}
Este fichero está tambien formado por 4 campos separados por el símbolo ``:''. El significado de cada campo es el siguiente:

\begin{enumerate}
    \item \textbf{Nombre del grupo: }Nombre del grupo. Debe existir en el sistema.
    \item \textbf{Contraseña encriptada: }Contraseña encriptada que sirve para que un usuario que no es miembro del grupo obtenga los permisos.
    
    Si el campo está vacio, entonces cualquier usuario puede obtener los privilegios del grupo.

    Si la contraseña comienza por una exclamacion, significa que esta está bloqueada.

    Si contiene una exclamacion o asterisco, los usuarios no podran acceder al grupo si no estan en el.

    \item \textbf{Administradores: }Lista de usuarios separados por coma que puede realizar operaciones como cambiar la contrasñéa del grupo o administrar los usuarios del mismo.
    \item \textbf{Miembros: }Lista de usaurios separados por coma. Los miembros del grupo pueden acceder al mismo sin necesitar la contraseña.
\end{enumerate}

\section{Segundo ejercicio}
En este ejercicio se pide modificar el valor de la variable ``LOGIN\_TIMEOUT'' y comprobar sus efectos con un usuario nuevo que se haya creado manualmente.

Para ello, modifico la variable, que estaba por defecto a 60 segundos:

%imagen del archivo con 60

Y lo cambio a otro valor, por ejemplo, 5 segundos:

%imagen del archivo con 5

A continuacion, creo el usuario llamado ``prueba'', le cambio la contraseña y hago login con él desde la terminal. Cuando se encuentre en la parte de pedir la contraseña de este usuario nuevo, se espera un tiempo hasta que la terminal devuevla un mensaje:

%mensaje de que han pasado 5 segundos

Como se puede ver, pone que han pasado 5 segundos y el acceso ha caducado.

Ahora, pruebo con otro valor, por ejemplo \textbf{PONER AQUI EL TIEMPO QUE QEURIA} segundos:

%imagen de timeout a otro valor

E intento iniciar sesion de nueov con el usuario ``prueba'' y espero en la parte de la contraseña.

%imagen timout nuevo

Como se puede ver, el timeout ahora es distinto.


\section{Tercer ejercicio}
En este ejercicio se pide crear un archivo y darle, mediante un ACL, permisos de lectura y escritura al usuario creado (en mi caso sigue siendo ``prueba'').

Para ello, mediante la orden ``touch'' creo el archivo denominado ``ejercicio3''.

Ahora bien, al menos en Ubuntu 22.04 no están las ordenes ``getacl/setacl'', sino que se llaman ``getfacl/setfacl''. El resultado no varía y tienen las mismas sintaxis.

%foto del get original
%caption: se puede ver que solo el usuario ``andres'' tiene los permisos

Ahora, con la orden ``setfacl'' se le dará al usuario ``prueba'' permisos ``rw''.

%foto del comando


Y ahora mostramos con ``getfacl'' el archivo anterior:

%foto del get nuevo

Como se puede observar, ahora aparece una linea que indica que el usuario ``prueba'' tiene permisos ``rw''.


\section{Ejercicio 4}
Con el comando ``ls'' muestro los archivos que se encuentran en el directorio ``/etc/pam.d'':

%IMAGEN ARCHIVOS PAM.D

A continuacion explicare dos archivos:

\subsection{/etc/pam.d/chfn}
Permite cambiar la informacion personal de un usuario tales como: el nombre, el numero de telefono, de habitacion, etc. Estos datos luego pueden ser leidos por comandos como ``finger''.

El contenido del archivo es:

%imagen del chfn

La funcion de la linea 7 es para no pedir la contraseña al usuario root cuando esté usando este comando. Para ello, hace uso del campo de control sufficient, que hace que si tiene exito retorne sin ejecutar mas modulos. Ademas, hgace uso del modulo ``pam\_rootok.so'' que hace que solo tenga extio si el usuario tiene el UID a 0 (es el usuario root).

\subsection{/etc/pam.d/chsh}
El comando ``chsh'' permite cambiar la shell por defecto del usuario que lo invoca. Si no se le pasa ningun parametro se activa el modo interactivo para realizar el cambio de shell.

El contenido del archivo es el siguiente:

%imagen de chsh


Como se puede ver en la linea 8, esta llamada lo que hace es prohibir el cambio de shell a no ser que se encuentre listada en ``/etc/shells''. Esto se consigue mediante el campo de control ``required'', que provocará un fallo de autenticacion en el sistema (ejecutará la linea siguiente, pero al ser irrelevante, no pasa nada) si el modulo falla. Tambien se consguie mediente la llamada al modulo ``pam\_shells.so'', que hace que si la shell pasada como parametro no se encuentra en ``/etc/shells'' dé un fallo.

La funcion de la linea 12 es de permitir al superusuario cambiar la shell sin ser necesdario introducir la contraseña. Esto se realiza mediante el campo de control ``sufficient'' y el modulo ``pam\_rootok.so''. Con ``sufficient'', cuando la orden tiene exito retorna sin ejecutar los demas modulos \textbf{COMPROBAR AFIRMACION: (Como es el ultimo puede retornar sin prblema)}. Ademas, con el modulo ``pam\_rootok.so'' autoriza al usuario con el UID 0 (root).


\section{Quinto ejercicio}
%Cabe destacar que en Ubuntu 22.04 los modulos de PAM no se encontraban en el directorio ``/etc/lib/security'', sino en el direcotiro ``/usr/lib/x86\_64-linux-gnu/security''. Los he tenido que encontrar con el comando ``find / -name ``pam\_*.so''''

%imagen de la salida
\subsection{Apartado a}
Es necesario modificar el archivo PAM ``common-password'' y en Ubuntu 22.04 ya como primera linea aparece el uso del modulo ``pam\_pwquality''. 

Ahora bien si leemos el manual de este modulo con ``man 8 pam\_pwquality'' se puede ver que hay un argumento denominado ``minlen'' y que valor por defecto es 8. No obstante, no se puede bajar del valor 4, ya que es un limite que tiene ``Cracklib'' y mostrara que la contrasñae es muy corta. Por eso, voy a poner el limite a \textbf{15 caracteres}.

%foto del argumento modificado de common-password

Y ahora al usar el comando ``passwd'' y poner una contraseña con menos de 15 palabras, muestra un error:

%imagen del error de passwd

Y al agotarse los intentos (que son 3) se sale del programa.
\subsection{Apartado b}
En esta parte he restringido el acceso al comando ``su'' para así evitar que un usuario que ponga el comando sin ``sudo'' pueda entrar. Si ponen ``sudo su'' sí van a poder entrar, pero esto es así ya que son usuarios administradores (y es una decisión de diseño, ya que en otro caso no podría usar nadie ``sudo''), en ese caso lo recomendable es deshabilitar el acceso al grupo ``sudo'' (en el caso de Ubuntu) para que no lo pueda usar (editando el archivo sudoers mediante el comando ``visudo'').

Para conseguir esto, es neceasrio modificar el arcvhio ``/etc/pam.d/su'' y añadir la siguiente línea al principio:

%foto de la linea de /etc/pam/su

Ahora, al ejecutar el comando ``su'' con un usuario nomral aparece lo siguiente:

%foto de fallo de autenticacion


En cambio, si el usuario puede usar ``sudo'', si puede acceder.

%foto del usuario prueba que no puede entrar
%caption: el usuario que se ha creado en esta practica no tiene permisos de sudo y por tanto no puede entrar de ninguna manera

La línea que he añadido lo que hace es comproba que la cuenta sea root (UID=0) y en caso de no serlo, no sigue ejecutando el archivo provocando un error de autenticación.


\section{Sexto ejercicio}
En Ubuntu 22.04 los cambios de contraseña no se almacenan en ``/var/log/messages'', sino en ``/var/log/auth.log''. \href{https://ubuntu.com/tutorials/viewing-and-monitoring-log-files#2-log-files-locations}{Enlace} a la guía.


Voy a crear el usuario ``ejercicio6'' y le voy a cambiar la contraseña:

%foto de la creacion y cambio de la contraseña de ejercicio6

Y ahora, al mostrar el archivo ``/var/log/auth.log'' aparecen las siguientes lineas:

%img /var/log/auth.log con la linea de cambio de contraseña de ejercicio6

\section{Séptimo ejercicio}
Para empezar, el propio archivon de sudoers recomienda usar la orden ``visudo''. POr tanto, es necesario usar ``visudo'' para que no haya problemas después. Además, por defecto usa el editor ``vi'', esto se puede cambiar usando el comando siguiente:

\verb|EDITOR=nano visudo|

Ahora, voy a asignarle permisos para usar sudo al usuario ``prueba'' que no se encuentra en el grupo ``sudo'', que es el que usa Ubuntu para dar permisos.

%foto de los grupos de prueba junto con sudo su fallido

Si añadimos la siguiente linea en el archivo ``sudoers'' tendremos acceso con sudo:

%foto con la modificacion


Y ahora al hacer una prueba se puede ver que ya funciona:

%foto de whoami con sudo su funcionando

\section{Octavo ejercicio}
Voy a examinar cada uno de los archivos y comprobar que se registran eventos que realizaré. Para ello, voy a dividir la explicacion en subsecciones para cada uno de los archivos.

\subsection{/var/log/lastlog}
ESte archivo almacena informacion sobre le ultimo inicio de sesion de los usuarios. Para acceder a la informacion es necesairio utilizar el comando ``lastlog'':

%foto de lastlog

Como se puede ver, el usuario ``ejercicio6'' nunca ha iniciado sesion en el sistema. Ahora si inicio sesion y vuelvo a usar la orden ``lastlog'' aparece lo siguiente:

%foto de lastlog con el usuario ejercicio6 con fecha

Ahora como se puede ver aparece la fecha del ultimo inicio de sesion del usuario ``ejercicio6''.

\subsection{/var/log/wtmp}
Almacena los login y logout de los distintos usuarios del sistema. Se accede con el comando ``last''. 

%foto de last normal

Ahora con el comando ``last --since today'' muestra solo la informacion de hoy.

%foto de last today

Y ahora voy a inicar sesion con el usuario ``prueba'' y lohout para ver como se almacena la informacion:

%foto de last today con prueba casi arriba del todo.
\subsection{/var/log/utmp}

\subsection{/var/log/btmp}

\subsection{/var/log/sudo}

\subsection{/var/log/messages}
\end{document}
